script = c("Makefile", "build.R"),
serve = TRUE,
command = "bundle exec jekyll build")
aa = function(x){
x+10
}
library(foreach)
library(doParallel)
install.packages("foreach")
install.packages("foreach")
install.packages("foreach")
install.packages("doParallel")
aa = function(x){
x+10
}
#### Import Libraries ####
if (!require("foreach")) install.packages("foreach",repos = "http://cran.us.r-project.org")
if (!require("doParallel")) install.packages("doParallel",repos = "http://cran.us.r-project.org")
if (!require("doSNOW")) install.packages("doSNOW",repos = "http://cran.us.r-project.org")
num_core = detectCores() - 1 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
install.packages("doSNOW")
if (!require("foreach")) install.packages("foreach",repos = "http://cran.us.r-project.org")
if (!require("doParallel")) install.packages("doParallel",repos = "http://cran.us.r-project.org")
if (!require("doSNOW")) install.packages("doSNOW",repos = "http://cran.us.r-project.org")
num_core = detectCores() - 1 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:dim(prod_list)[1], .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(10*i)
output
}
num_core = detectCores() - 1 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(10*i)
output
}
stopCluster(cl) # stop the cluster in the end!!
end.time = proc.time() - start.time
cl
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
aa = function(x){
x+10
}
output = aa(10*i)
output
}
stopCluster(cl) # stop the cluster in the end!!
end.time = proc.time() - start.time
output_par
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
aa = function(x){
x+10
}
output = aa(10*i)
output
}
stopCluster(cl) # stop the cluster in the end!!
output_par
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
aa = function(x){
x+10
}
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(10*i)
output
}
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
aa = function(x){
x+10
}
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(10*i)
output
}
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
aa = function(x){
x+10
}
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = 10*i
output
}
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
aa = function(x){
x+10
}
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(10*i)
output
}
stopCluster(cl) # stop the cluster in the end!!
end.time = proc.time() - start.time
output_par
ts(c(1:10))
?ts
?forecast
rollmean
install.packages("zoo")
?rollmean
library(zoo)
?rollmean
rollmean(c(1:10))
rollmean(c(1:10),2)
library(zoo)
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
aa = function(x, k){
y = rollmean(x, k) * 10
}
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(1:i), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
end.time = proc.time() - start.time
output_par
library(zoo)
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
aa = function(x, k){
y = zoo::rollmean(x, k) * 10
}
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(1:i), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
end.time = proc.time() - start.time
output_par
if (!require("foreach")) install.packages("foreach",repos = "http://cran.us.r-project.org")
if (!require("doParallel")) install.packages("doParallel",repos = "http://cran.us.r-project.org")
if (!require("doSNOW")) install.packages("doSNOW",repos = "http://cran.us.r-project.org")
library(zoo)
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
aa = function(x, k){
y = rollmean(x, k) * 10
}
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
library(zoo)
output = aa(c(1:i), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
end.time = proc.time() - start.time
output_par
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(1:i), 3)
output
}
#### Define the functions ####
aa = function(x, k){
library(zoo)
y = rollmean(x, k) * 10
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(1:i), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
(end.time = proc.time() - start.time)
output_par
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(4:i), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
(end.time = proc.time() - start.time)
output_par
aa = function(x, k){
library(zoo)
y = rollmean(x, k) * 10
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(i:100), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
(end.time = proc.time() - start.time)
output_par
aa = function(x, k){
library(zoo)
y = rollmean(x, k) * 10
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(i:20), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
(end.time = proc.time() - start.time)
output_par
#### Define the functions ####
aa = function(x, k){
library(zoo)
y = rollmean(x, k) * 10
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(i:20), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
(end.time = proc.time() - start.time)
output_par
aa = function(x, k){
library(zoo)
y = rollmean(x, k) * 10
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(i:10), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
(end.time = proc.time() - start.time)
output_par
aa = function(x, k){
library(zoo)
y = rollmean(x, k) * 10
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(i:15), 3)
output
}
stopCluster(cl) # stop the cluster in the end!!
(end.time = proc.time() - start.time)
output_par
if (!require("foreach")) install.packages("foreach",repos = "http://cran.us.r-project.org")
if (!require("doParallel")) install.packages("doParallel",repos = "http://cran.us.r-project.org")
if (!require("doSNOW")) install.packages("doSNOW",repos = "http://cran.us.r-project.org")
library(foreach)
library(doParallel)
library(doSNOW)
#### Define the function ####
aa = function(x, k){
if (!require("zoo")) install.packages("zoo",repos = "http://cran.us.r-project.org")
library(zoo)
y = rollmean(x, k) * 10
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(i:15), 3)
output
}
stopCluster(cl) # stop the cluster in the end
(end.time = proc.time() - start.time)
output_par
if (!require("foreach")) install.packages("foreach",repos = "http://cran.us.r-project.org")
if (!require("doParallel")) install.packages("doParallel",repos = "http://cran.us.r-project.org")
if (!require("doSNOW")) install.packages("doSNOW",repos = "http://cran.us.r-project.org")
if (!require("zoo")) install.packages("zoo",repos = "http://cran.us.r-project.org")
library(foreach)
library(doParallel)
library(doSNOW)
#### Define the function ####
aa = function(x, k){
library(zoo)
y = rollmean(x, k) * 10
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:10, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(i:15), 3)
output
}
stopCluster(cl) # stop the cluster in the end
(end.time = proc.time() - start.time)
output_par
if(!require("devtools")) install.packages("devtools")
if(!require("servr")) install.packages("servr")
if(!require("knitr")) install.packages("knitr")
library(servr)
#devtools::install_github("choux130/servr_2")
library(devtools)
#ls("package:servr")
#jekyll
#build_jekyll
#trace("jekyll",edit=TRUE)
#dev_mode()
servr::jekyll(dir = ".", input = c(".", "_source", "_posts"),
output = c(".", "_posts", "_posts"),
script = c("Makefile", "build.R"),
serve = TRUE,
command = "bundle exec jekyll build")
aa = function(x, k){
library(zoo)
y = rollmean(x, k)
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:5, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(i:30), 10)
output
}
stopCluster(cl) # stop the cluster in the end
(end.time = proc.time() - start.time)
output_par
aa = function(x, k){
library(zoo)
y = rollmean(x, k)
}
#### Run Parallelly ####
num_core = detectCores() - 2 # detect # of CPU cores
cl = makeCluster(num_core, outfile = "") # define the clusters
registerDoSNOW(cl)
# print out the progress for every iteration
progress <- function(n) cat(sprintf("task %d is complete\n", n))
opts <- list(progress=progress)
start.time = proc.time()
# the default .combine = list
output_par =
foreach(i = 1:5, .options.snow = opts, .errorhandling = 'pass') %dopar%
{
output = aa(c(i:10), 5)
output
}
stopCluster(cl) # stop the cluster in the end
(end.time = proc.time() - start.time)
output_par
